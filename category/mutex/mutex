


 import (
	"fmt"
	"sync"
)

func main() {
	var count = 0
	// ä½¿ç”¨WaitGroupç­‰å¾…10ä¸ªgoroutineå®Œæˆ
	var wg sync.WaitGroup
	wg.Add(10)
	for i := 0; i < 10; i++ {
			go func() {
					defer wg.Done()
					// å¯¹å˜é‡countæ‰§è¡Œ10æ¬¡åŠ 1
					for j := 0; j < 100000; j++ {
							count++
					}
			}()
	}
	// ç­‰å¾…10ä¸ªgoroutineå®Œæˆ
	wg.Wait()
	fmt.Println(count)
}





 // count++æ“ä½œçš„æ±‡ç¼–ä»£ç 
 MOVQ    "".count(SB), AX
 LEAQ    1(AX), CX
 MOVQ    CX, "".count(SB)


 Go race detector æ˜¯åŸºäº Google çš„ C/C++ sanitizers æŠ€æœ¯å®ç°çš„ï¼Œç¼–è¯‘å™¨é€šè¿‡æ¢æµ‹æ‰€æœ‰çš„å†…å­˜è®¿é—®ï¼ŒåŠ å…¥ä»£ç èƒ½ç›‘è§†å¯¹è¿™äº›å†…å­˜åœ°å€çš„è®¿é—®ï¼ˆè¯»è¿˜æ˜¯å†™ï¼‰ã€‚åœ¨ä»£ç è¿è¡Œçš„æ—¶å€™ï¼Œrace detector å°±èƒ½ç›‘æ§åˆ°å¯¹å…±äº«å˜é‡çš„éåŒæ­¥è®¿é—®ï¼Œå‡ºç° race çš„æ—¶å€™ï¼Œå°±ä¼šæ‰“å°å‡ºè­¦å‘Šä¿¡æ¯


go run -race counter.go

go è¯­è¨€æŸ¥çœ‹æ±‡ç¼–ä»£ç å‘½ä»¤
go tool compile -race -S counter.go


 package main


 import (
		 "fmt"
		 "sync"
 )


 func main() {
		 // äº’æ–¥é”ä¿æŠ¤è®¡æ•°å™¨
		 var mu sync.Mutex
		 // è®¡æ•°å™¨çš„å€¼
		 var count = 0
		 
		 // è¾…åŠ©å˜é‡ï¼Œç”¨æ¥ç¡®è®¤æ‰€æœ‰çš„goroutineéƒ½å®Œæˆ
		 var wg sync.WaitGroup
		 wg.Add(10)

		 // å¯åŠ¨10ä¸ªgourontine
		 for i := 0; i < 10; i++ {
				 go func() {
						 defer wg.Done()
						 // ç´¯åŠ 10ä¸‡æ¬¡
						 for j := 0; j < 100000; j++ {
								 mu.Lock()
								 count++
								 mu.Unlock()
						 }
				 }()
		 }
		 wg.Wait()
		 fmt.Println(count)
 }



func main() {
	var counter Counter
	var wg sync.WaitGroup
	wg.Add(10)
	for i := 0; i < 10; i++ {
			go func() {
					defer wg.Done()
					for j := 0; j < 100000; j++ {
							counter.Lock()
							counter.Count++
							counter.Unlock()
					}
			}()
	}
	wg.Wait()
	fmt.Println(counter.Count)
}


type Counter struct {
	sync.Mutex
	Count uint64
}




func main() {
	// å°è£…å¥½çš„è®¡æ•°å™¨
	var counter Counter

	var wg sync.WaitGroup
	wg.Add(10)

	// å¯åŠ¨10ä¸ªgoroutine
	for i := 0; i < 10; i++ {
			go func() {
					defer wg.Done()
					// æ‰§è¡Œ10ä¸‡æ¬¡ç´¯åŠ 
					for j := 0; j < 100000; j++ {
							counter.Incr() // å—åˆ°é”ä¿æŠ¤çš„æ–¹æ³•
					}
			}()
	}
	wg.Wait()
	fmt.Println(counter.Count())
}

// çº¿ç¨‹å®‰å…¨çš„è®¡æ•°å™¨ç±»å‹
type Counter struct {
	CounterType int
	Name        string

	mu    sync.Mutex
	count uint64
}

// åŠ 1çš„æ–¹æ³•ï¼Œå†…éƒ¨ä½¿ç”¨äº’æ–¥é”ä¿æŠ¤
func (c *Counter) Incr() {
	c.mu.Lock()
	c.count++
	c.mu.Unlock()
}

// å¾—åˆ°è®¡æ•°å™¨çš„å€¼ï¼Œä¹Ÿéœ€è¦é”ä¿æŠ¤
func (c *Counter) Count() uint64 {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.count
}





ç­‰å¾…çš„goroutineä»¬æ˜¯ä»¥FIFOæ’é˜Ÿçš„
1ï¼‰å½“Mutexå¤„äºæ­£å¸¸æ¨¡å¼æ—¶ï¼Œè‹¥æ­¤æ—¶æ²¡æœ‰æ–°goroutineä¸é˜Ÿå¤´goroutineç«äº‰ï¼Œåˆ™é˜Ÿå¤´goroutineè·å¾—ã€‚è‹¥æœ‰æ–°goroutineç«äº‰å¤§æ¦‚ç‡æ–°goroutineè·å¾—ã€‚
2ï¼‰å½“é˜Ÿå¤´goroutineç«äº‰é”å¤±è´¥1msåï¼Œå®ƒä¼šå°†Mutexè°ƒæ•´ä¸ºé¥¥é¥¿æ¨¡å¼ã€‚è¿›å…¥é¥¥é¥¿æ¨¡å¼åï¼Œé”çš„æ‰€æœ‰æƒä¼šç›´æ¥ä»è§£é”goroutineç§»äº¤ç»™é˜Ÿå¤´goroutineï¼Œæ­¤æ—¶æ–°æ¥çš„goroutineç›´æ¥æ”¾å…¥é˜Ÿå°¾ã€‚

3ï¼‰å½“ä¸€ä¸ªgoroutineè·å–é”åï¼Œå¦‚æœå‘ç°è‡ªå·±æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ä¸­çš„ä»»ä½•ä¸€ä¸ª#1å®ƒæ˜¯é˜Ÿåˆ—ä¸­æœ€åä¸€ä¸ª#2å®ƒç­‰å¾…é”çš„æ—¶é—´å°‘äº1msï¼Œåˆ™å°†é”åˆ‡æ¢å›æ­£å¸¸æ¨¡å¼

ä»¥ä¸Šç®€ç•¥ç¿»è¯‘è‡ªhttps://golang.org/src/sync/mutex.go ä¸­æ³¨é‡ŠMutex fairness.



è¯¾åæ€è€ƒé¢˜ï¼š
åˆ†äº«ä¸¤ç¯‡æ–‡ç« å§ï¼ˆæˆ‘è¿˜æ²¡çœ‹å®ŒğŸ˜‚ï¼‰

é¸Ÿå”çš„ï¼šsync.mutex æºä»£ç åˆ†æ
https://colobu.com/2018/12/18/dive-into-sync-mutex/

golangæºç é˜…è¯»-sync.Mutex
https://studygolang.com/articles/17017


è¿™ä¸ªè¯¾ç¨‹æˆ‘æƒ³ä¸€ç›´è·Ÿç€èµ°ï¼Œä¸å•å•åªæ˜¯çœ‹ï¼Œæˆ‘æƒ³åœ¨å¸æ”¶è¯¾ç¨‹ç²¾åçš„åŒæ—¶ï¼Œä¹Ÿè¿›è¡Œç‹¬ç«‹çš„æ€è€ƒï¼Œç„¶åè¾“å‡ºï¼Œæ€»ç»“ï¼ŒåŠ æ·±ç†è§£ã€‚å› æ­¤åˆ›å»ºäº†ä¸€ä¸ªä»“åº“ï¼Œæ¬¢è¿å¤§å®¶åœ¨å­¦ä¹ çš„åŒæ—¶ä¸€èµ·åšåˆ°æ‰‹ä¸­æœ‰ç ï¼Œé¡¹ç›®åœ°å€:https://github.com/wuqinqiang/Go_Concurrency



goçš„goroutine è°ƒåº¦ä¸­ï¼Œå†…éƒ¨ç»´æŠ¤äº†é˜Ÿåˆ—ï¼Œgoroutineåœ¨æŠ¢å é”çš„æ—¶å€™ï¼Œä¼šè‡ªæ—‹ä¸€æ®µæ—¶é—´ï¼Œå¦‚æœæŠ¢å å¤±è´¥ï¼Œè¿™ä¸ªgoroutineä¼šè¢«æ”¾åˆ°ä¸€ä¸ªFIFOé˜Ÿåˆ—ä¸­ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œé”é‡Šæ”¾æ—¶ï¼Œä¼šä¼˜å…ˆå”¤é†’é˜Ÿå¤´çš„goroutineï¼Œå³é˜Ÿå¤´çš„goroutineä¼˜å…ˆè·å¾—Mutexã€‚


è€å¸ˆï¼Œä¸ºä»€ä¹ˆè¯»ä¹Ÿè¦åŠ é”å‘¢ï¼Ÿ
ä½œè€…å›å¤: è¯´æ¥è¯é•¿ã€‚
1.mutexä¿æŠ¤çš„ä¸´ç•ŒåŒºã€‚å¦‚æœè¯»çš„æ—¶å€™ä¸åŠ é”ï¼Œå¯èƒ½ä¼šé€ æˆä¸ä¸€è‡´çš„åæœï¼Œæ¯”å¦‚éƒ¨åˆ†å˜é‡è¢«ä¿®æ”¹äº†ã€‚
2.å¦‚æœä¸´ç•ŒåŒºæ¯”è¾ƒç®€å•ï¼Œæ¯”å¦‚ä¸€ä¸ªint64è¯»å†™ï¼Œä¹Ÿå¯èƒ½åœ¨ä¸€äº›cpuæ¶æ„ä¸‹æœ‰å¯è§æ€§é—®é¢˜ï¼Œå¯¼è‡´åˆ«çš„goroutineå¯¹å˜é‡çš„å†™è¯»goroutineçœ‹ä¸åˆ°



æœ‰ä¸¤ç§æƒ…å†µ
1. å¦‚æœå½“å‰æœ‰åç¨‹è¿›å…¥è‡ªæ—‹æ¨¡å¼ï¼Œå½“å‰åç¨‹ä¼šæˆåŠŸè·å–åˆ°é”
2. å¦‚æœæ²¡æœ‰åç¨‹è¿›å…¥è‡ªé€‰æ¨¡å¼ï¼Œé‡Šæ”¾é”çš„åç¨‹ä¼šé‡Šæ”¾çš„ä¿¡å·é‡ä¼šæˆåŠŸå”¤é†’ç­‰å¾…é˜Ÿåˆ—ä¸­çš„åç¨‹ï¼Œè¯¥å¸ç¨‹ä¼šæˆåŠŸè·å–åˆ°é”ï¼Œå¹¶ä¸”æŠŠç­‰å¾…è®¡æ•°å™¨å‡1.

è€å¸ˆï¼šåœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œä¿¡å·é‡å”¤é†’çš„åç¨‹æˆåŠŸè·å–åˆ°é”ä¹‹åï¼Œè¯¥Mutexçš„æ¨¡å¼ä¼šæ”¹å˜å—ï¼Ÿ
ä½œè€…å›å¤: è¿›å…¥è‡ªæ—‹ä¸ä¸€å®šä¼šè·å–åˆ°é”ã€‚
é¥¥é¥¿æ¨¡å¼ä¸ä¸€å®šæ”¹å˜ï¼Œçœ‹æ–‡ç« ã€‚åªæœ‰ç­‰å¾…æ—¶é—´å°äºé˜ˆå€¼æˆ–è€…æ— ç­‰å¾…è€…æ—¶æ‰ä¼šæ”¹å˜æ¨¡å¼


æ€§èƒ½å’Œå…¬å¹³æ€§çš„


â€œåˆç‰ˆâ€çš„ Mutex ä½¿ç”¨ä¸€ä¸ª flag æ¥è¡¨ç¤ºé”æ˜¯å¦è¢«æŒæœ‰ï¼Œå®ç°æ¯”è¾ƒç®€å•ï¼›åæ¥ç…§é¡¾åˆ°æ–°æ¥çš„ goroutineï¼Œæ‰€ä»¥ä¼šè®©æ–°çš„ goroutine ä¹Ÿå°½å¯èƒ½åœ°å…ˆè·å–åˆ°é”ï¼Œè¿™æ˜¯ç¬¬äºŒä¸ªé˜¶æ®µï¼Œæˆ‘æŠŠå®ƒå«ä½œâ€œç»™æ–°äººæœºä¼šâ€ï¼›é‚£ä¹ˆï¼Œæ¥ä¸‹æ¥å°±æ˜¯ç¬¬ä¸‰é˜¶æ®µâ€œå¤šç»™äº›æœºä¼šâ€ï¼Œç…§é¡¾æ–°æ¥çš„å’Œè¢«å”¤é†’çš„ goroutineï¼›ä½†æ˜¯è¿™æ ·ä¼šå¸¦æ¥é¥¥é¥¿é—®é¢˜ï¼Œæ‰€ä»¥ç›®å‰åˆåŠ å…¥äº†é¥¥é¥¿çš„è§£å†³æ–¹æ¡ˆï¼Œä¹Ÿå°±æ˜¯ç¬¬å››é˜¶æ®µâ€œè§£å†³é¥¥é¥¿â€

CASï¼ˆcompare-and-swapï¼Œæˆ–è€… compare-and-setï¼‰å°†è¿™ä¸ª flag è®¾ç½®ä¸º 1

CAS æ˜¯å®ç°äº’æ–¥é”å’ŒåŒæ­¥åŸè¯­çš„åŸºç¡€, CAS æŒ‡ä»¤å°†ç»™å®šçš„å€¼å’Œä¸€ä¸ªå†…å­˜åœ°å€ä¸­çš„å€¼è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœå®ƒä»¬æ˜¯åŒä¸€ä¸ªå€¼ï¼Œå°±ä½¿ç”¨æ–°å€¼æ›¿æ¢å†…å­˜åœ°å€ä¸­çš„å€¼ï¼Œè¿™ä¸ªæ“ä½œæ˜¯åŸå­æ€§çš„



   // CASæ“ä½œï¼Œå½“æ—¶è¿˜æ²¡æœ‰æŠ½è±¡å‡ºatomicåŒ…
	 func cas(val *int32, old, new int32) bool
	 func semacquire(*int32)
	 func semrelease(*int32)
	 // äº’æ–¥é”çš„ç»“æ„ï¼ŒåŒ…å«ä¸¤ä¸ªå­—æ®µ
	 type Mutex struct {
			 key  int32 // é”æ˜¯å¦è¢«æŒæœ‰çš„æ ‡è¯†
			 sema int32 // ä¿¡å·é‡ä¸“ç”¨ï¼Œç”¨ä»¥é˜»å¡/å”¤é†’goroutine
	 }
	 
	 // ä¿è¯æˆåŠŸåœ¨valä¸Šå¢åŠ deltaçš„å€¼
	 func xadd(val *int32, delta int32) (new int32) {
			 for {
					 v := *val
					 if cas(val, v, v+delta) {
							 return v + delta
					 }
			 }
			 panic("unreached")
	 }
	 
	 // è¯·æ±‚é”
	 func (m *Mutex) Lock() {
			 if xadd(&m.key, 1) == 1 { //æ ‡è¯†åŠ 1ï¼Œå¦‚æœç­‰äº1ï¼ŒæˆåŠŸè·å–åˆ°é”
					 return
			 }
			 semacquire(&m.sema) // å¦åˆ™é˜»å¡ç­‰å¾…
	 }
	 
	 func (m *Mutex) Unlock() {
			 if xadd(&m.key, -1) == 0 { // å°†æ ‡è¯†å‡å»1ï¼Œå¦‚æœç­‰äº0ï¼Œåˆ™æ²¡æœ‰å…¶å®ƒç­‰å¾…è€…
					 return
			 }
			 semrelease(&m.sema) // å”¤é†’å…¶å®ƒé˜»å¡çš„goroutine
	 }    



ä» 1.14 ç‰ˆæœ¬èµ·ï¼ŒGo å¯¹ defer åšäº†ä¼˜åŒ–ï¼Œé‡‡ç”¨æ›´æœ‰æ•ˆçš„å†…è”æ–¹å¼ï¼Œå–ä»£ä¹‹å‰çš„ç”Ÿæˆ defer å¯¹è±¡åˆ° defer chain ä¸­ï¼Œdefer å¯¹è€—æ—¶çš„å½±å“å¾®ä¹å…¶å¾®äº†ï¼Œæ‰€ä»¥åŸºæœ¬ä¸Šä¿®æ”¹æˆä¸‹é¢ç®€æ´çš„å†™æ³•ä¹Ÿæ²¡é—®é¢˜




ç»™æ–°äººæœºä¼š
type Mutex struct {
	state int32
	sema  uint32
}


const (
	mutexLocked = 1 << iota // mutex is locked
	mutexWoken
	mutexWaiterShift = iota
)




func (m *Mutex) Lock() {
	// Fast path: å¹¸è¿caseï¼Œèƒ½å¤Ÿç›´æ¥è·å–åˆ°é”
	if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
			return
	}

	awoke := false
	for {
			old := m.state
			new := old | mutexLocked // æ–°çŠ¶æ€åŠ é”
			if old&mutexLocked != 0 {
					new = old + 1<<mutexWaiterShift //ç­‰å¾…è€…æ•°é‡åŠ ä¸€
			}
			if awoke {
					// goroutineæ˜¯è¢«å”¤é†’çš„ï¼Œ
					// æ–°çŠ¶æ€æ¸…é™¤å”¤é†’æ ‡å¿—
					new &^= mutexWoken
			}
			if atomic.CompareAndSwapInt32(&m.state, old, new) {//è®¾ç½®æ–°çŠ¶æ€
					if old&mutexLocked == 0 { // é”åŸçŠ¶æ€æœªåŠ é”
							break
					}
					runtime.Semacquire(&m.sema) // è¯·æ±‚ä¿¡å·é‡
					awoke = true
			}
	}
}


func (m *Mutex) Unlock() {
	// Fast path: drop lock bit.
	new := atomic.AddInt32(&m.state, -mutexLocked) //å»æ‰é”æ ‡å¿—
	if (new+mutexLocked)&mutexLocked == 0 { //æœ¬æ¥å°±æ²¡æœ‰åŠ é”
			panic("sync: unlock of unlocked mutex")
	}

	old := new
	for {
			if old>>mutexWaiterShift == 0 || old&(mutexLocked|mutexWoken) != 0 { // æ²¡æœ‰ç­‰å¾…è€…ï¼Œæˆ–è€…æœ‰å”¤é†’çš„waiterï¼Œæˆ–è€…é”åŸæ¥å·²åŠ é”
					return
			}
			new = (old - 1<<mutexWaiterShift) | mutexWoken // æ–°çŠ¶æ€ï¼Œå‡†å¤‡å”¤é†’goroutineï¼Œå¹¶è®¾ç½®å”¤é†’æ ‡å¿—
			if atomic.CompareAndSwapInt32(&m.state, old, new) {
					runtime.Semrelease(&m.sema)
					return
			}
			old = m.state
	}
}




å¤šç»™äº›æœºä¼šåœ¨ 2015 å¹´ 2 æœˆçš„æ”¹åŠ¨ä¸­ï¼Œå¦‚æœæ–°æ¥çš„ goroutine æˆ–è€…æ˜¯è¢«å”¤é†’çš„ goroutine é¦–æ¬¡è·å–ä¸åˆ°é”ï¼Œå®ƒä»¬å°±ä¼šé€šè¿‡è‡ªæ—‹ï¼ˆspinï¼Œé€šè¿‡å¾ªç¯ä¸æ–­å°è¯•ï¼Œspin çš„é€»è¾‘æ˜¯åœ¨runtime å®ç°çš„ï¼‰çš„æ–¹å¼ï¼Œå°è¯•æ£€æŸ¥é”æ˜¯å¦è¢«é‡Šæ”¾ã€‚åœ¨å°è¯•ä¸€å®šçš„è‡ªæ—‹æ¬¡æ•°åï¼Œå†æ‰§è¡ŒåŸæ¥çš„é€»è¾‘
func (m *Mutex) Lock() {
	// Fast path: å¹¸è¿ä¹‹è·¯ï¼Œæ­£å¥½è·å–åˆ°é”
	if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
			return
	}

	awoke := false
	iter := 0
	for { // ä¸ç®¡æ˜¯æ–°æ¥çš„è¯·æ±‚é”çš„goroutine, è¿˜æ˜¯è¢«å”¤é†’çš„goroutineï¼Œéƒ½ä¸æ–­å°è¯•è¯·æ±‚é”
			old := m.state // å…ˆä¿å­˜å½“å‰é”çš„çŠ¶æ€
			new := old | mutexLocked // æ–°çŠ¶æ€è®¾ç½®åŠ é”æ ‡å¿—
			if old&mutexLocked != 0 { // é”è¿˜æ²¡è¢«é‡Šæ”¾
					if runtime_canSpin(iter) { // è¿˜å¯ä»¥è‡ªæ—‹
							if !awoke && old&mutexWoken == 0 && old>>mutexWaiterShift != 0 &&
									atomic.CompareAndSwapInt32(&m.state, old, old|mutexWoken) {
									awoke = true
							}
							runtime_doSpin()
							iter++
							continue // è‡ªæ—‹ï¼Œå†æ¬¡å°è¯•è¯·æ±‚é”
					}
					new = old + 1<<mutexWaiterShift
			}
			if awoke { // å”¤é†’çŠ¶æ€
					if new&mutexWoken == 0 {
							panic("sync: inconsistent mutex state")
					}
					new &^= mutexWoken // æ–°çŠ¶æ€æ¸…é™¤å”¤é†’æ ‡è®°
			}
			if atomic.CompareAndSwapInt32(&m.state, old, new) {
					if old&mutexLocked == 0 { // æ—§çŠ¶æ€é”å·²é‡Šæ”¾ï¼Œæ–°çŠ¶æ€æˆåŠŸæŒæœ‰äº†é”ï¼Œç›´æ¥è¿”å›
							break
					}
					runtime_Semacquire(&m.sema) // é˜»å¡ç­‰å¾…
					awoke = true // è¢«å”¤é†’
					iter = 0
			}
	}
}





é€šè¿‡åŠ å…¥é¥¥é¥¿æ¨¡å¼ï¼Œå¯ä»¥é¿å…æŠŠæœºä¼šå…¨éƒ½ç•™ç»™æ–°æ¥çš„ goroutineï¼Œä¿è¯äº†è¯·æ±‚é”çš„ goroutine è·å–é”çš„å…¬å¹³æ€§
Mutex ç»ä¸å®¹å¿ä¸€ä¸ª goroutine è¢«è½ä¸‹ï¼Œæ°¸è¿œæ²¡æœ‰æœºä¼šè·å–é”ã€‚ä¸æŠ›å¼ƒä¸æ”¾å¼ƒæ˜¯å®ƒçš„å®—æ—¨ï¼Œè€Œä¸”å®ƒä¹Ÿå°½å¯èƒ½åœ°è®©ç­‰å¾…è¾ƒé•¿çš„ goroutine æ›´æœ‰æœºä¼šè·å–åˆ°é”ã€‚

type Mutex struct {
	state int32
	sema  uint32
}

const (
	mutexLocked = 1 << iota // mutex is locked
	mutexWoken
	mutexStarving // ä»stateå­—æ®µä¸­åˆ†å‡ºä¸€ä¸ªé¥¥é¥¿æ ‡è®°
	mutexWaiterShift = iota

	starvationThresholdNs = 1e6   //1ms 1 æ¯«ç§’
)

func (m *Mutex) Lock() {
	// Fast path: å¹¸è¿ä¹‹è·¯ï¼Œä¸€ä¸‹å°±è·å–åˆ°äº†é”
	if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
			return
	}
	// Slow pathï¼šç¼“æ…¢ä¹‹è·¯ï¼Œå°è¯•è‡ªæ—‹ç«äº‰æˆ–é¥¥é¥¿çŠ¶æ€ä¸‹é¥¥é¥¿goroutineç«äº‰
	m.lockSlow()
}

func (m *Mutex) lockSlow() {
	var waitStartTime int64
	starving := false // æ­¤goroutineçš„é¥¥é¥¿æ ‡è®°
	awoke := false // å”¤é†’æ ‡è®°
	iter := 0 // è‡ªæ—‹æ¬¡æ•°
	old := m.state // å½“å‰çš„é”çš„çŠ¶æ€
	for {
			// é”æ˜¯éé¥¥é¥¿çŠ¶æ€ï¼Œé”è¿˜æ²¡è¢«é‡Šæ”¾ï¼Œå°è¯•è‡ªæ—‹
			if old&(mutexLocked|mutexStarving) == mutexLocked && runtime_canSpin(iter) {
					if !awoke && old&mutexWoken == 0 && old>>mutexWaiterShift != 0 &&
							atomic.CompareAndSwapInt32(&m.state, old, old|mutexWoken) {
							awoke = true
					}
					runtime_doSpin()
					iter++
					old = m.state // å†æ¬¡è·å–é”çš„çŠ¶æ€ï¼Œä¹‹åä¼šæ£€æŸ¥æ˜¯å¦é”è¢«é‡Šæ”¾äº†
					continue
			}
			new := old
			if old&mutexStarving == 0 {
					new |= mutexLocked // éé¥¥é¥¿çŠ¶æ€ï¼ŒåŠ é”
			}
			if old&(mutexLocked|mutexStarving) != 0 {
					new += 1 << mutexWaiterShift // waiteræ•°é‡åŠ 1
			}
			if starving && old&mutexLocked != 0 {
					new |= mutexStarving // è®¾ç½®é¥¥é¥¿çŠ¶æ€
			}
			if awoke {
					if new&mutexWoken == 0 {
							throw("sync: inconsistent mutex state")
					}
					new &^= mutexWoken // æ–°çŠ¶æ€æ¸…é™¤å”¤é†’æ ‡è®°
			}
			// æˆåŠŸè®¾ç½®æ–°çŠ¶æ€
			if atomic.CompareAndSwapInt32(&m.state, old, new) {
					// åŸæ¥é”çš„çŠ¶æ€å·²é‡Šæ”¾ï¼Œå¹¶ä¸”ä¸æ˜¯é¥¥é¥¿çŠ¶æ€ï¼Œæ­£å¸¸è¯·æ±‚åˆ°äº†é”ï¼Œè¿”å›
					if old&(mutexLocked|mutexStarving) == 0 {
							break // locked the mutex with CAS
					}
					// å¤„ç†é¥¥é¥¿çŠ¶æ€

					// å¦‚æœä»¥å‰å°±åœ¨é˜Ÿåˆ—é‡Œé¢ï¼ŒåŠ å…¥åˆ°é˜Ÿåˆ—å¤´
					queueLifo := waitStartTime != 0
					if waitStartTime == 0 {
							waitStartTime = runtime_nanotime()
					}
					// é˜»å¡ç­‰å¾…
					runtime_SemacquireMutex(&m.sema, queueLifo, 1)
					// å”¤é†’ä¹‹åæ£€æŸ¥é”æ˜¯å¦åº”è¯¥å¤„äºé¥¥é¥¿çŠ¶æ€
					starving = starving || runtime_nanotime()-waitStartTime > starvationThresholdNs
					old = m.state
					// å¦‚æœé”å·²ç»å¤„äºé¥¥é¥¿çŠ¶æ€ï¼Œç›´æ¥æŠ¢åˆ°é”ï¼Œè¿”å›
					if old&mutexStarving != 0 {
							if old&(mutexLocked|mutexWoken) != 0 || old>>mutexWaiterShift == 0 {
									throw("sync: inconsistent mutex state")
							}
							// æœ‰ç‚¹ç»•ï¼ŒåŠ é”å¹¶ä¸”å°†waiteræ•°å‡1
							delta := int32(mutexLocked - 1<<mutexWaiterShift)
							if !starving || old>>mutexWaiterShift == 1 {
									delta -= mutexStarving // æœ€åä¸€ä¸ªwaiteræˆ–è€…å·²ç»ä¸é¥¥é¥¿äº†ï¼Œæ¸…é™¤é¥¥é¥¿æ ‡è®°
							}
							atomic.AddInt32(&m.state, delta)
							break
					}
					awoke = true
					iter = 0
			} else {
					old = m.state
			}
	}
}


func (m *Mutex) Unlock() {
	// Fast path: drop lock bit.
	new := atomic.AddInt32(&m.state, -mutexLocked)
	if new != 0 {
			m.unlockSlow(new)
	}
}

func (m *Mutex) unlockSlow(new int32) {
	if (new+mutexLocked)&mutexLocked == 0 {
			throw("sync: unlock of unlocked mutex")
	}
	if new&mutexStarving == 0 {
			old := new
			for {
					if old>>mutexWaiterShift == 0 || old&(mutexLocked|mutexWoken|mutexStarving) != 0 {
							return
					}
					new = (old - 1<<mutexWaiterShift) | mutexWoken
					if atomic.CompareAndSwapInt32(&m.state, old, new) {
							runtime_Semrelease(&m.sema, false, 1)
							return
					}
					old = m.state
			}
	} else {
			runtime_Semrelease(&m.sema, true, 1)
	}
}




